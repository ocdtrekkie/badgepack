<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badgepack</title>
    <style>
        :root {
            --color-primary: #2196F3;
            --color-primary-hover: #1976D2;
            --color-success: #4CAF50;
            --color-error: #f44336;
            --color-bg: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #212121;
            --color-text-secondary: #757575;
            --color-border: #e0e0e0;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background-color: var(--color-surface);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            margin: 0;
            color: var(--color-primary);
            font-size: 28px;
        }

        .subtitle {
            color: var(--color-text-secondary);
            margin-top: 8px;
            font-size: 14px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background-color: var(--color-surface);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            margin-top: 0;
            margin-bottom: 16px;
            color: var(--color-primary);
            font-size: 18px;
            border-bottom: 2px solid var(--color-border);
            padding-bottom: 12px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 14px;
            color: var(--color-text);
        }

        input[type="file"],
        input[type="text"],
        select,
        textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            color: var(--color-text);
            background-color: #fafafa;
        }

        input[type="file"] {
            padding: 8px;
        }

        input[type="file"]::file-selector-button {
            background-color: var(--color-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 12px;
            font-weight: 500;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: var(--color-primary-hover);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }

        .btn-success {
            background-color: var(--color-success);
            color: white;
        }

        .btn-success:hover {
            background-color: #45a049;
        }

        .btn-danger {
            background-color: var(--color-error);
            color: white;
        }

        .btn-danger:hover {
            background-color: #da190b;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 14px;
        }

        .alert-success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }

        .alert-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        .alert-info {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #bbdefb;
        }

        .filters {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .badge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .badge-card {
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 16px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .badge-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .badge-card.selected {
            border-color: var(--color-primary);
            background-color: #e3f2fd;
        }

        .badge-image {
            width: 80px;
            height: 80px;
            object-fit: contain;
            margin-bottom: 12px;
            background: white;
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        .badge-name {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 8px;
            color: var(--color-text);
        }

        .badge-info {
            font-size: 13px;
            color: var(--color-text-secondary);
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .badge-dates {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin: 8px 0;
            padding: 8px 0;
            border-top: 1px solid var(--color-border);
            border-bottom: 1px solid var(--color-border);
        }

        .date-item {
            margin: 4px 0;
        }

        .badge-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .tag {
            display: inline-block;
            background-color: var(--color-primary);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }

        .tag.issuer {
            background-color: #FF9800;
        }

        .tag.provider {
            background-color: #9C27B0;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, var(--color-primary), #1976D2);
            color: white;
            padding: 16px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-number {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 13px;
            opacity: 0.9;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--color-text-secondary);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--color-surface);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 12px;
        }

        .modal-close {
            float: right;
            font-size: 24px;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        .modal-close:hover {
            color: var(--color-text);
        }

        .modal-badge-image {
            width: 120px;
            height: 120px;
            object-fit: contain;
            margin-bottom: 16px;
            background: white;
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        .json-display {
            background-color: #f5f5f5;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }

        .no-results {
            text-align: center;
            padding: 30px;
            color: var(--color-text-secondary);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--color-text-secondary);
        }

        @media (max-width: 480px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .badge-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèÜ Badgepack</h1>
            <p class="subtitle">Upload, manage, and organize your OpenBadges 2.0 and 3.0 credentials</p>
        </header>

        <div class="main-grid">
            <!-- Upload Card -->
            <div class="card">
                <h2>üì§ Upload Credentials</h2>
                <div id="uploadAlert"></div>
                <div class="form-group">
                    <label for="credentialFile">Select Badge File(s)</label>
                    <input type="file" id="credentialFile" accept=".json,.png,.svg" multiple>
                    <small style="color: var(--color-text-secondary); display: block; margin-top: 8px;">
                        Upload JSON, PNG, or SVG files containing OpenBadges 2.0 or 3.0 credentials
                    </small>
                </div>
                <button class="btn btn-primary" onclick="uploadCredentials()" style="width: 100%;">
                    üì• Upload
                </button>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--color-border);">
                    <label style="margin-bottom: 12px;">Backend Status:</label>
                    <div id="backendStatus" style="font-size: 13px; color: var(--color-text-secondary);">
                        Checking connection...
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div>
                <!-- Statistics -->
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-number" id="totalBadges">0</div>
                        <div class="stat-label">Total Badges</div>
                    </div>
                    <div class="stat-box" style="background: linear-gradient(135deg, #FF9800, #F57C00);">
                        <div class="stat-number" id="uniqueIssuers">0</div>
                        <div class="stat-label">Issuers</div>
                    </div>
                    <div class="stat-box" style="background: linear-gradient(135deg, #9C27B0, #7B1FA2);">
                        <div class="stat-number" id="uniqueProviders">0</div>
                        <div class="stat-label">Providers</div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="filters">
                    <select id="issuerFilter" onchange="applyFilters()">
                        <option value="">All Issuers</option>
                    </select>
                    <select id="providerFilter" onchange="applyFilters()">
                        <option value="">All Providers</option>
                    </select>
                    <input type="text" id="searchFilter" placeholder="Search badges..." onkeyup="applyFilters()">
                    <button class="btn btn-sm btn-primary" onclick="clearFilters()">Clear Filters</button>
                </div>

                <!-- Badges Display -->
                <div id="badgesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">üìã</div>
                        <p>No badges loaded yet. Upload or refresh to load badges from the server.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-close" onclick="closeModal()">&times;</span>
                <span id="modalTitle">Badge Details</span>
            </div>
            <div id="modalBody"></div>
            <div class="action-buttons" style="margin-top: 20px; justify-content: flex-end;">
                <button class="btn btn-danger btn-sm" id="deleteBtn" onclick="deleteSelectedBadge()">Delete</button>
                <button class="btn btn-primary btn-sm" onclick="closeModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Include pako for zlib decompression -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2/dist/pako.min.js"></script>

    <script>
        // Configuration
        const API_BASE = '/api';
        let selectedBadgeId = null;

        // Initialize
        window.addEventListener('load', () => {
            checkBackendConnection();
            loadBadgesFromBackend();
        });

        // Check backend connection
        async function checkBackendConnection() {
            const statusDiv = document.getElementById('backendStatus');
            try {
                const response = await fetch(`${API_BASE}/health`);
                if (response.ok) {
                    statusDiv.innerHTML = '‚úÖ <span style="color: #4CAF50;">Backend connected</span>';
                } else {
                    statusDiv.innerHTML = '‚ùå <span style="color: #f44336;">Backend error</span>';
                }
            } catch (error) {
                statusDiv.innerHTML = '‚ùå <span style="color: #f44336;">Backend not reachable</span><br><small>Make sure Flask server is running on port 5000</small>';
            }
        }

        // Load badges from backend
        async function loadBadgesFromBackend() {
            try {
                const response = await fetch(`${API_BASE}/badges`);
                if (!response.ok) throw new Error('Failed to load badges');
                
                const badges = await response.json();
                updateDisplay(badges);
            } catch (error) {
                console.error('Error loading badges:', error);
                showAlert(document.getElementById('uploadAlert'), 'Failed to load badges from server', 'error');
            }
        }

        // Upload credentials
        async function uploadCredentials() {
            const fileInput = document.getElementById('credentialFile');
            const files = fileInput.files;
            const alertDiv = document.getElementById('uploadAlert');

            if (files.length === 0) {
                showAlert(alertDiv, 'Please select at least one file', 'error');
                return;
            }

            let successCount = 0;
            let errorCount = 0;
            const promises = [];

            for (let file of files) {
                promises.push(
                    processBadgeFile(file).then(async badgeData => {
                        if (!badgeData) {
                            errorCount++;
                            return;
                        }

                        try {
                            const formData = new FormData();
                            formData.append('badgeData', JSON.stringify(badgeData));
                            formData.append('file', file);

                            const response = await fetch(`${API_BASE}/badges`, {
                                method: 'POST',
                                body: formData
                            });

                            if (response.ok) {
                                successCount++;
                                console.log('Badge uploaded:', badgeData.badgeName);
                            } else {
                                errorCount++;
                                console.error('Upload failed for:', file.name);
                            }
                        } catch (error) {
                            errorCount++;
                            console.error('Error uploading badge:', error);
                        }
                    })
                );
            }

            Promise.all(promises).then(() => {
                if (successCount > 0) {
                    showAlert(alertDiv, `Successfully uploaded ${successCount} badge(s)`, 'success');
                    fileInput.value = '';
                    loadBadgesFromBackend();
                }
                if (errorCount > 0) {
                    showAlert(alertDiv, `Failed to parse ${errorCount} file(s)`, 'error');
                }
            });
        }

        // Process badge file
        async function processBadgeFile(file) {
            const isJSON = file.name.endsWith('.json');
            const isPNG = file.name.endsWith('.png');
            const isSVG = file.name.endsWith('.svg');

            try {
                if (isJSON) {
                    const content = await file.text();
                    const data = JSON.parse(content);
                    return await processBadgeData(data);
                } else if (isPNG) {
                    const buffer = await file.arrayBuffer();
                    const data = extractFromPNG(buffer);
                    if (data) return await processBadgeData(data);
                } else if (isSVG) {
                    const content = await file.text();
                    const data = extractFromSVG(content);
                    if (data) return await processBadgeData(data);
                }
            } catch (error) {
                console.error('Error processing file:', file.name, error);
            }
            return null;
        }

        // Extract from PNG
        function extractFromPNG(buffer) {
            const view = new Uint8Array(buffer);
            const pngSigLen = 8;

            if (buffer.byteLength < pngSigLen + 12) return null;

            let offset = pngSigLen;
            const foundChunks = [];

            while (offset < view.length - 4) {
                if (offset + 8 > view.length) break;

                const length = (view[offset] << 24) | (view[offset + 1] << 16) |
                              (view[offset + 2] << 8) | view[offset + 3];
                offset += 4;

                const chunkType = String.fromCharCode(view[offset], view[offset + 1],
                                                      view[offset + 2], view[offset + 3]);
                offset += 4;

                const chunkDataStart = offset;
                const chunkDataEnd = offset + length;

                if (chunkDataEnd > view.length) break;

                if ((chunkType === 'iTXt' || chunkType === 'tEXt' || chunkType === 'zTXt') && length > 1) {
                    try {
                        let keywordEnd = chunkDataStart;
                        while (keywordEnd < chunkDataEnd && view[keywordEnd] !== 0) {
                            keywordEnd++;
                        }

                        if (keywordEnd >= chunkDataEnd) {
                            offset = chunkDataEnd + 4;
                            continue;
                        }

                        const keyword = new TextDecoder().decode(view.slice(chunkDataStart, keywordEnd));
                        let badgeText = null;

                        if (chunkType === 'iTXt') {
                            if (keywordEnd + 2 <= chunkDataEnd) {
                                const compressionFlag = view[keywordEnd + 1];
                                const dataStart = keywordEnd + 2;
                                const data = view.slice(dataStart, chunkDataEnd);

                                if (compressionFlag === 1) {
                                    try {
                                        badgeText = pako.inflate(data, { to: 'string' });
                                    } catch (e) {
                                        badgeText = new TextDecoder('utf-8', { fatal: false }).decode(data);
                                    }
                                } else {
                                    badgeText = new TextDecoder('utf-8', { fatal: false }).decode(data);
                                }
                            }
                        } else if (chunkType === 'tEXt') {
                            badgeText = new TextDecoder('utf-8', { fatal: false }).decode(view.slice(keywordEnd + 1, chunkDataEnd));
                        } else if (chunkType === 'zTXt') {
                            if (keywordEnd + 1 < chunkDataEnd) {
                                try {
                                    badgeText = pako.inflate(view.slice(keywordEnd + 2, chunkDataEnd), { to: 'string' });
                                } catch (e) {
                                    badgeText = new TextDecoder('utf-8', { fatal: false }).decode(view.slice(keywordEnd + 2, chunkDataEnd));
                                }
                            }
                        }

                        if (badgeText) {
                            badgeText = badgeText.trim();
                            foundChunks.push({ keyword, type: chunkType, data: badgeText });
                        }
                    } catch (e) {
                        console.warn('Error parsing PNG chunk:', e);
                    }
                }

                offset = chunkDataEnd + 4;
            }

            if (foundChunks.length === 0) return null;

            for (let chunk of foundChunks) {
                if (chunk.keyword === 'openbadges') return tryParseData(chunk.data);
            }

            for (let chunk of foundChunks) {
                if (chunk.keyword.toLowerCase().includes('assertion') ||
                    chunk.keyword.toLowerCase().includes('badge')) {
                    return tryParseData(chunk.data);
                }
            }

            for (let chunk of foundChunks) {
                if (chunk.data.startsWith('{') || chunk.data.startsWith('[') ||
                    chunk.data.startsWith('http')) {
                    return tryParseData(chunk.data);
                }
            }

            return null;
        }

        // Extract from SVG
        function extractFromSVG(content) {
            const parser = new DOMParser();
            try {
                const svgDoc = parser.parseFromString(content, 'image/svg+xml');
                const assertions = svgDoc.querySelectorAll('[*|assertion]');

                for (let assertion of assertions) {
                    const verifyAttr = assertion.getAttributeNS('http://openbadges.org', 'verify') ||
                                     assertion.getAttribute('verify');

                    if (assertion.textContent && assertion.textContent.trim()) {
                        try {
                            let text = assertion.textContent.trim();
                            if (text.startsWith('<![CDATA[')) text = text.slice(9, -3);
                            return JSON.parse(text);
                        } catch (e) {}
                    }

                    if (verifyAttr) return { _badgeUrl: verifyAttr };
                }
            } catch (e) {
                console.error('Error parsing SVG:', e);
            }
            return null;
        }

        // Parse badge data
        function tryParseData(textOrBytes) {
            let text;

            if (textOrBytes instanceof Uint8Array) {
                try {
                    text = new TextDecoder('utf-8', { fatal: false }).decode(textOrBytes);
                } catch (e) {
                    text = Array.from(textOrBytes).map(byte => String.fromCharCode(byte)).join('');
                }
            } else if (typeof textOrBytes === 'string') {
                text = textOrBytes;
            } else {
                return null;
            }

            if (!text || text.length === 0) return null;

            text = text.replace(/^\ufeff/, '').trim();

            const jsonStart = Math.min(
                text.indexOf('{') >= 0 ? text.indexOf('{') : Infinity,
                text.indexOf('[') >= 0 ? text.indexOf('[') : Infinity
            );

            if (jsonStart !== Infinity && jsonStart > 0) {
                text = text.substring(jsonStart);
            }

            try {
                const result = JSON.parse(text);
                return result;
            } catch (jsonErr) {
                if (text.startsWith('http://') || text.startsWith('https://')) {
                    return { _badgeUrl: text };
                }

                try {
                    let decoded = atob(text);
                    decoded = decoded.replace(/^\ufeff/, '').trim();
                    return JSON.parse(decoded);
                } catch (e) {
                    return null;
                }
            }
        }

        // Fetch remote data
        async function fetchRemoteData(url) {
            if (!url || typeof url !== 'string') return null;

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(url, {
                    mode: 'cors',
                    headers: { 'Accept': 'application/json' },
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.warn('Error fetching remote data from', url, ':', error);
            }
            return null;
        }

        // Process badge data - enriches with remote data if available
        async function processBadgeData(data) {
            if (!data || typeof data !== 'object') return null;

            try {
                let badge;

                // Detect if this is OB3 or OB2
                const isOB3 = data['@context'] && (Array.isArray(data.type) ? 
                    data.type.includes('VerifiableCredential') || data.type.includes('AchievementCredential') : 
                    (data.type && (data.type.includes('VerifiableCredential') || data.type.includes('AchievementCredential'))));

                if (isOB3) {
                    badge = await parseOB3(data);
                } else {
                    badge = await parseOB2(data);
                }

                return badge;
            } catch (e) {
                console.error('Error parsing badge:', e);
                return null;
            }
        }

        // Parse OB2 - with remote data fetching
        async function parseOB2(data) {
            let badgeClassData = null;
            let issuanceDate = data.issuedOn || null;
            let expiresDate = data.expires || null;

            // Try to fetch remote badge class if badge is a URL
            if (data.badge && typeof data.badge === 'string') {
                badgeClassData = await fetchRemoteData(data.badge);
                console.log('Fetched BadgeClass from:', data.badge, badgeClassData);
            } else if (data.badge && typeof data.badge === 'object') {
                badgeClassData = data.badge;
            }

            // Try to fetch from verify.url if no direct date found
            if (!issuanceDate && !expiresDate && data.verify?.url) {
                const assertionData = await fetchRemoteData(data.verify.url);
                if (assertionData) {
                    issuanceDate = issuanceDate || assertionData.issuedOn || null;
                    expiresDate = expiresDate || assertionData.expires || null;
                }
            }

            // Extract badge name and description from BadgeClass
            let badgeName = null;
            let description = null;
            if (badgeClassData) {
                badgeName = badgeClassData.name || null;
                description = badgeClassData.description || null;
            }

            return {
                id: 'badge_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                version: '2.0',
                type: data.type || 'Unknown',
                badgeName: badgeName || data.badge?.name || null,
                description: description || data.badge?.description || null,
                issuerName: data.badge?.issuer?.name || data.issuer?.name || null,
                issuerUrl: data.badge?.issuer?.url || data.issuer?.url || null,
                issuerEmail: data.badge?.issuer?.email || data.issuer?.email || null,
                credentialProvider: detectProvider(data),
                issuanceDate: issuanceDate,
                expiresDate: expiresDate,
                recipientIdentity: typeof data.recipient === 'object' ? data.recipient.identity : data.recipient,
                rawData: data
            };
        }

        // Parse OB3 - with remote data fetching
        async function parseOB3(data) {
            return {
                id: 'badge_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                version: '3.0',
                type: Array.isArray(data.type) ? data.type.join(', ') : data.type || 'Unknown',
                badgeName: data.credentialSubject?.achievement?.name || null,
                description: data.credentialSubject?.achievement?.description || null,
                issuerName: data.issuer?.name || null,
                issuerUrl: data.issuer?.id || data.issuer?.url || null,
                issuerEmail: data.issuer?.email || null,
                credentialProvider: detectProvider(data),
                issuanceDate: data.validFrom || data.issuanceDate || null,
                expiresDate: data.validTo || data.expirationDate || null,
                recipientIdentity: data.credentialSubject?.id || null,
                rawData: data
            };
        }

        // Detect provider
        function detectProvider(data) {
            const rawStr = JSON.stringify(data).toLowerCase();
            if (rawStr.includes('linkedin')) return 'LinkedIn';
            if (rawStr.includes('credly')) return 'Credly';
            if (rawStr.includes('badgr')) return 'Badgr';
            if (rawStr.includes('mozilla')) return 'Mozilla';
            return 'Unknown';
        }

        // Format date for display
        function formatDate(dateString) {
            if (!dateString) return null;
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return dateString;
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
            } catch (e) {
                return dateString;
            }
        }

        // Update display
        function updateDisplay(badges) {
            updateStats(badges);
            updateFilters(badges);
            applyFilters();
        }

        // Update stats
        function updateStats(badges) {
            document.getElementById('totalBadges').textContent = badges.length;

            const issuers = new Set(badges.map(b => b.issuerName || b.issuerUrl || 'Unknown').filter(Boolean));
            document.getElementById('uniqueIssuers').textContent = issuers.size;

            const providers = new Set(badges.map(b => b.credentialProvider).filter(Boolean));
            document.getElementById('uniqueProviders').textContent = providers.size;
        }

        // Update filters
        function updateFilters(badges) {
            const issuers = new Set(badges.map(b => b.issuerName || b.issuerUrl || 'Unknown').filter(Boolean));
            const providers = new Set(badges.map(b => b.credentialProvider).filter(Boolean));

            const issuerSelect = document.getElementById('issuerFilter');
            const providerSelect = document.getElementById('providerFilter');

            issuerSelect.innerHTML = '<option value="">All Issuers</option>';
            Array.from(issuers).sort().forEach(issuer => {
                issuerSelect.innerHTML += `<option value="${issuer}">${issuer}</option>`;
            });

            providerSelect.innerHTML = '<option value="">All Providers</option>';
            Array.from(providers).sort().forEach(provider => {
                providerSelect.innerHTML += `<option value="${provider}">${provider}</option>`;
            });
        }

        // Apply filters
        async function applyFilters() {
            const issuerFilter = document.getElementById('issuerFilter').value;
            const providerFilter = document.getElementById('providerFilter').value;
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();

            try {
                const criteria = {};
                if (issuerFilter) criteria.issuer = issuerFilter;
                if (providerFilter) criteria.provider = providerFilter;
                if (searchFilter) criteria.search = searchFilter;

                let response;
                if (Object.keys(criteria).length > 0) {
                    response = await fetch(`${API_BASE}/badges/search`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(criteria)
                    });
                } else {
                    response = await fetch(`${API_BASE}/badges`);
                }

                const badges = await response.json();
                displayBadges(badges);
            } catch (error) {
                console.error('Error filtering badges:', error);
            }
        }

        // Display badges
        function displayBadges(badges) {
            const container = document.getElementById('badgesContainer');

            if (badges.length === 0) {
                container.innerHTML = '<div class="no-results">No badges match your filters</div>';
                return;
            }

            container.innerHTML = '<div class="badge-grid">' +
                badges.map(badge => {
                    let datesHtml = '';
                    const issuedDate = formatDate(badge.issuanceDate);
                    const expiresDate = formatDate(badge.expiresDate);
                    
                    if (issuedDate || expiresDate) {
                        datesHtml = '<div class="badge-dates">';
                        if (issuedDate) {
                            datesHtml += `<div class="date-item">üìÖ Issued: ${issuedDate}</div>`;
                        }
                        if (expiresDate) {
                            datesHtml += `<div class="date-item">‚è∞ Expires: ${expiresDate}</div>`;
                        }
                        datesHtml += '</div>';
                    }

                    return `
                        <div class="badge-card" onclick="openBadgeDetails('${badge.id}')">
                            ${badge.hasImage ? `<img src="${API_BASE}/badges/${badge.id}/image" alt="${badge.badgeName}" class="badge-image">` : ''}
                            <div class="badge-name">${badge.badgeName || 'Unnamed Badge'}</div>
                            <div class="badge-info">
                                <strong>Issuer:</strong> ${badge.issuerName || badge.issuerUrl || 'Unknown'}<br>
                                <strong>Provider:</strong> ${badge.credentialProvider}
                            </div>
                            ${datesHtml}
                            <div class="badge-tags">
                                <span class="tag issuer">${badge.issuerName || badge.issuerUrl || 'Unknown'}</span>
                                <span class="tag provider">${badge.credentialProvider}</span>
                            </div>
                        </div>
                    `;
                }).join('') +
            '</div>';
        }

        // Open badge details
        async function openBadgeDetails(badgeId) {
            selectedBadgeId = badgeId;

            try {
                const response = await fetch(`${API_BASE}/badges/${badgeId}`);
                if (!response.ok) throw new Error('Badge not found');

                const badge = await response.json();

                document.getElementById('modalTitle').textContent = badge.badgeName || 'Badge Details';

                let imageHtml = '';
                if (badge.hasImage) {
                    imageHtml = `<img src="${API_BASE}/badges/${badgeId}/image" alt="${badge.badgeName}" class="modal-badge-image">`;
                }

                const details = `
                    <div style="margin-bottom: 20px;">
                        ${imageHtml}
                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Badge Name</strong>
                            <div style="font-size: 15px; margin-top: 4px;">${badge.badgeName || 'N/A'}</div>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Description</strong>
                            <div style="font-size: 14px; margin-top: 4px; line-height: 1.5;">${badge.description || 'N/A'}</div>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Issuer Name</strong>
                            <div style="font-size: 15px; margin-top: 4px;">${badge.issuerName || 'N/A'}</div>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Issuer URL</strong>
                            <div style="font-size: 14px; margin-top: 4px; word-break: break-all;">${badge.issuerUrl || 'N/A'}</div>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Credential Provider</strong>
                            <div style="font-size: 15px; margin-top: 4px;">${badge.credentialProvider}</div>
                        </div>

                        ${badge.issuanceDate ? `
                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Issuance Date</strong>
                            <div style="font-size: 15px; margin-top: 4px;">${formatDate(badge.issuanceDate) || badge.issuanceDate}</div>
                        </div>
                        ` : ''}

                        ${badge.expiresDate ? `
                        <div style="margin-bottom: 16px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Expiration Date</strong>
                            <div style="font-size: 15px; margin-top: 4px;">${formatDate(badge.expiresDate) || badge.expiresDate}</div>
                        </div>
                        ` : ''}

                        <div style="margin-bottom: 20px;">
                            <strong style="font-size: 14px; color: var(--color-text-secondary);">Raw JSON Data</strong>
                            <div class="json-display">${JSON.stringify(badge.rawData, null, 2)}</div>
                        </div>
                    </div>
                `;

                document.getElementById('modalBody').innerHTML = details;
                document.getElementById('detailModal').classList.add('active');
            } catch (error) {
                console.error('Error opening badge details:', error);
            }
        }

        // Close modal
        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
            selectedBadgeId = null;
        }

        // Delete badge
        async function deleteSelectedBadge() {
            if (!selectedBadgeId) return;

            if (!confirm('Are you sure you want to delete this badge?')) return;

            try {
                const response = await fetch(`${API_BASE}/badges/${selectedBadgeId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    closeModal();
                    loadBadgesFromBackend();
                    showAlert(document.getElementById('uploadAlert'), 'Badge deleted successfully', 'success');
                } else {
                    showAlert(document.getElementById('uploadAlert'), 'Failed to delete badge', 'error');
                }
            } catch (error) {
                console.error('Error deleting badge:', error);
                showAlert(document.getElementById('uploadAlert'), 'Delete error: ' + error.message, 'error');
            }
        }

        // Clear filters
        function clearFilters() {
            document.getElementById('issuerFilter').value = '';
            document.getElementById('providerFilter').value = '';
            document.getElementById('searchFilter').value = '';
            applyFilters();
        }

        // Show alert
        function showAlert(container, message, type) {
            container.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            if (type === 'success') {
                setTimeout(() => {
                    container.innerHTML = '';
                }, 4000);
            }
        }

        // Close modal when clicking outside
        document.getElementById('detailModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });
    </script>
</body>
</html>
